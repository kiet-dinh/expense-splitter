---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - gsd-module-test/src/engine/math.ts
  - gsd-module-test/src/engine/math.test.ts
autonomous: true

must_haves:
  truths:
    - "Splitting $10.00 three ways produces shares that sum to exactly 1000 cents"
    - "Proportional tip/tax distribution using largest-remainder produces zero residual"
    - "Dollar string parsing converts to integer cents without floating-point error"
    - "Cent formatting converts back to display-ready dollar strings"
    - "Edge cases (zero total, single recipient, equal remainders) are handled correctly"
  artifacts:
    - path: "gsd-module-test/src/engine/math.ts"
      provides: "Calculation engine with distribute, dollarsToCents, centsToDollars"
      exports: ["distribute", "dollarsToCents", "centsToDollars"]
    - path: "gsd-module-test/src/engine/math.test.ts"
      provides: "Unit tests proving integer-cent arithmetic and largest-remainder rounding"
      min_lines: 50
  key_links:
    - from: "gsd-module-test/src/engine/math.test.ts"
      to: "gsd-module-test/src/engine/math.ts"
      via: "import { distribute, dollarsToCents, centsToDollars }"
      pattern: "import.*from.*./math"
---

<objective>
Implement the calculation engine using TDD: integer-cent arithmetic and largest-remainder rounding distribution.

Purpose: This is the trust foundation of the app. If the math is wrong, nothing else matters. TDD ensures every edge case is covered before moving to UI.
Output: A tested, pure TypeScript calculation module with zero React dependencies.
</objective>

<execution_context>
@C:/Users/Kiet Dinh/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Kiet Dinh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>Calculation Engine: Integer-Cent Arithmetic and Largest-Remainder Distribution</name>
  <files>gsd-module-test/src/engine/math.ts, gsd-module-test/src/engine/math.test.ts</files>
  <behavior>
    The engine provides three pure functions with no side effects and no React dependencies:

    **distribute(totalCents: number, weights: number[]): number[]**
    - Splits totalCents proportionally to weights using the largest-remainder method
    - Returns integer cent allocations that sum to EXACTLY totalCents (zero residual)
    - Tiebreaker: when remainders are equal, lower index gets the extra cent (stable, deterministic)
    - Cases:
      - distribute(1000, [1, 1, 1]) → [334, 333, 333] (sum = 1000)
      - distribute(1500, [3000, 2500, 2000]) → proportional shares summing to 1500
      - distribute(0, [1, 1, 1]) → [0, 0, 0]
      - distribute(333, [1]) → [333]
      - distribute(100, [1, 1]) → [50, 50]
      - distribute(1, [1, 1, 1]) → [1, 0, 0] (only one cent to give)
      - distribute(1000, []) → []

    **dollarsToCents(input: string): number**
    - Parses dollar strings to integer cents WITHOUT using floating-point multiplication
    - Splits on decimal point, parses dollars and cents separately
    - Handles: "10", "10.5", "10.50", "$10.00", "0.99"
    - Cases:
      - dollarsToCents("10.00") → 1000
      - dollarsToCents("33.33") → 3333 (NOT 3332.999... from parseFloat * 100)
      - dollarsToCents("10") → 1000
      - dollarsToCents("10.5") → 1050
      - dollarsToCents("$10.00") → 1000
      - dollarsToCents("0.99") → 99

    **centsToDollars(cents: number): string**
    - Formats integer cents to display string with 2 decimal places
    - Cases:
      - centsToDollars(1000) → "10.00"
      - centsToDollars(333) → "3.33"
      - centsToDollars(1) → "0.01"
      - centsToDollars(0) → "0.00"
  </behavior>
  <implementation>
    Follow the patterns from 01-RESEARCH.md exactly:

    1. `distribute()`: Use the largest-remainder method (Hamilton method).
       - Compute raw shares: `(weight / weightSum) * totalCents`
       - Floor each share, track remainders
       - Sort by remainder descending (tiebreak by index ascending)
       - Award one extra cent to top entries until sum matches totalCents
       - Restore original order and return

    2. `dollarsToCents()`: String-split approach to avoid floating-point.
       - Strip non-numeric characters except decimal point
       - Split on "."
       - Parse dollars * 100 + cents (padded/sliced to 2 digits)
       - Use parseInt, NOT parseFloat * 100

    3. `centsToDollars()`: Simple division with toFixed(2).
       - `(cents / 100).toFixed(2)` is safe here because toFixed handles display rounding
       - This is the ONLY place division by 100 is acceptable (output formatting only)

    CRITICAL CONSTRAINTS:
    - Zero React imports in math.ts — this is pure TypeScript
    - All monetary values as integer cents — no floating-point storage
    - All exports must be named exports (not default)
  </implementation>
</feature>

<verification>
From gsd-module-test directory:
```bash
npx vitest run src/engine/math.test.ts
```
All tests must pass. Specifically verify:
1. distribute(1000, [1, 1, 1]) shares sum to exactly 1000
2. distribute(1500, [3000, 2500, 2000]) shares sum to exactly 1500 (proportional tip)
3. dollarsToCents("33.33") === 3333 (no floating-point leak)
4. Edge cases: zero total, single recipient, empty weights
</verification>

<success_criteria>
- All unit tests pass with `npx vitest run`
- distribute() produces zero residual for all test cases (shares sum to exactly totalCents)
- dollarsToCents() converts without floating-point error (verified by "33.33" → 3333 test)
- centsToDollars() round-trips correctly with dollarsToCents for standard values
- math.ts has zero React imports
- Phase 1 Success Criteria #1 met: $10.00 split three ways sums to 1000 cents
- Phase 1 Success Criteria #2 met: proportional tip distribution produces zero residual
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
